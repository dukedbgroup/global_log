import scala.io.Source
import scala.collection.mutable.MutableList
import java.io._
import scala.util.control.Exception.allCatch
import scala.collection.immutable.ListMap

/**
 * @author yuzhanghan1982
 */
object GCLogAnalyzer {

  def isLongNumber(s: String): Boolean = (allCatch opt s.toLong).isDefined

  var executionTime: Double = 0
  var progressionTime: Double = 0
  var collectionTime: Double = 0

  def main(args: Array[String]) {

    if(args.length != 4) {
      println("Usage:\nscala GCLogAnalyzer <APP_ID> <WORKERNODE_HOSTNAME> <\"Parallel GC\"|\"G1\"> <EXECUTION_TIME: in minutes>\nUsage example:\nscala GCLogAnalyzer application_1448400088838_0327 slave5 \"Parallel GC\" 1")
      System.exit(0)
    }
//    args.foreach {
//      a =>
//        println(a)
//    }
    if (args(2) == "G1")
      getGCStatistics_G1(args)
    else if (args(2) == "Parallel GC")
      getGCStatistics_ParallelGC(args)

    //    getGeneratedHeapDataSize(args)
  }

  def getGCStatistics_G1(args: Array[String]) {

    println("Application:\t\t\t" + args(0))
    println("Worker node:\t\t\t" + args(1))

    var dirname: String = null
    var filename: String = null

    // han
    //adapt this to the path you store the driver and worker output folder generated by my memory profiler
    dirname = "/home/yuzhang/spark-1.5.1/logs/" + args(0) + "/" + args(1)
    (new File(dirname)).listFiles.filter(_.isDirectory).foreach {
      dir_container =>
        filename = dir_container.getAbsolutePath + "/stdout"
        println(dir_container.getAbsolutePath)

        //   [Eden: 282.0M(282.0M)->0.0B(282.0M) Survivors: 24.0M->24.0M Heap: 492.0M(6144.0M)->218.0M(6144.0M)]
        executionTime = args(3).toDouble * 60
        println("Execution time:\t" + executionTime + " sec")

        var fraction: Double = 0
        var lines_list: List[String] = Source.fromFile(new File(filename)).getLines().filter(l => l.startsWith("   [Eden:") || l.startsWith(" [Times: ")).toList
        var lines_iterator = lines_list.iterator
        var totalTime: Double = 0
        var avgTime: Double = 0
        var numberOfGCs: Int = 0
        var totalSize: Double = 0
        var avgSize: Double = 0

        var line: String = null
        while (lines_iterator.hasNext == true) {
          line = lines_iterator.next()
          if (line.startsWith("   [Eden:")) {
            numberOfGCs += 1
            val tokens = line.split("\\s+").iterator
            while (tokens.hasNext) {
              if (tokens.next() == "Heap:") {
                //            println(tokens.next())
                var t1 = tokens.next().split("M|\\(|\\)|->|\\]").filter(t => t.length > 0).toArray
                totalSize += t1(0).toDouble - t1(2).toDouble
                /*
            t1.foreach {
              t =>
                print(t + "\t")
            }
            println(totalSize)
            */
              }
            }
            val nextLine = lines_iterator.next()
            val t = nextLine.split("\\s+").filter(token => token.startsWith("real="))(0)
            val value = t.substring(t.indexOf('=') + 1).toDouble
            totalTime += value
          }
        }

        avgTime = totalTime / numberOfGCs
        println("-------- Young GC --------")
        println("Number of Young GCs:\t\t" + numberOfGCs)
        println("Total pause of Young GCs:\t" + totalTime + " sec")
        println("Average pause of Young GCs:\t" + avgTime + " sec")
        fraction = totalTime / executionTime
        println("Fraction of Young GCs:\t\t" + fraction)
        avgSize = totalSize / numberOfGCs
        println("Total size of Young GCs:\t" + totalSize + " MB")
        println("Average size of Young GCs:\t" + avgSize + " MB")

        collectionTime += totalTime

        //[GC cleanup 1116M->879M(6144M), 0.0054560 secs]
        fraction = 0
        totalTime = 0
        avgTime = 0
        numberOfGCs = 0
        totalSize = 0
        avgSize = 0

        Source.fromFile(new File(filename)).getLines().filter(l => l.contains("[GC cleanup")).foreach {
          l =>
            numberOfGCs += 1
            l.split("\\s").filter(token => token.contains("->")).foreach {
              t =>
                var t1 = t.split("M|\\(|\\)|->|\\]").filter(t => t.length > 0).toArray
                totalSize += t1(0).toDouble - t1(1).toDouble
              //            println(t + " " + t1(0).toDouble - t1(1).toDouble)
            }
            val t2 = l.split("\\s").toArray
            totalTime += t2(t2.indexOf("secs]") - 1).toDouble
        }
        avgTime = totalTime / numberOfGCs
        println("-------- cleanups --------")
        println("Number of cleanups:\t\t" + numberOfGCs)
        println("Total pause of cleanups:\t" + totalTime + " sec")
        println("Average pause of cleanups:\t" + avgTime + " sec")
        fraction = totalTime / executionTime
        println("Fraction of cleanups:\t\t" + fraction)
        avgSize = totalSize / numberOfGCs
        println("Total size of cleanups:\t\t" + totalSize + " MB")
        println("Average size of cleanups:\t" + avgSize + " MB")

        collectionTime += totalTime

        //2015-10-15T19:39:53.683+0000: 616.458: [Full GC2015-10-15T19:39:54.023+0000: 616.798: [SoftReference, 1098 refs, 0.0001570 secs]2015-10-15T19:39:54.023+0000: 616.798: [WeakReference, 558 refs, 0.0000540 secs]2015-10-15T19:39:54.023+0000: 616.798: [FinalReference, 108 refs, 0.0000610 secs]2015-10-15T19:39:54.023+0000: 616.798: [PhantomReference, 5 refs, 39 refs, 0.0000170 secs]2015-10-15T19:39:54.023+0000: 616.798: [JNI Weak Reference, 0.0000100 secs] 5673M->517M(6144M), 2.3053630 secs]
        fraction = 0
        totalTime = 0
        avgTime = 0
        numberOfGCs = 0
        totalSize = 0
        avgSize = 0

        Source.fromFile(new File(filename)).getLines().filter(l => l.contains("[Full GC")).foreach {
          l =>
            numberOfGCs += 1
            l.split("\\s").filter(token => token.contains("->")).foreach {
              t =>
                var t1 = t.split("M|\\(|\\)|->|\\]").filter(t => t.length > 0).toArray
                totalSize += t1(0).toDouble - t1(1).toDouble
                val d = t1(0).toDouble - t1(1).toDouble
                println(t + " " + d)
            }
            val t2 = l.split("\\s").toArray
            totalTime += t2(t2.lastIndexOf("secs]") - 1).toDouble
        }
        avgTime = totalTime / numberOfGCs
        println("-------- Full GCs --------")
        println("Number of full GCs:\t\t" + numberOfGCs)
        println("Total pause of full GCs:\t" + totalTime + " sec")
        println("Average pause of full GCs:\t" + avgTime + " sec")
        fraction = totalTime / executionTime
        println("Fraction of full GCs:\t\t" + fraction)
        avgSize = totalSize / numberOfGCs
        println("Total size of full GCs:\t\t" + totalSize + " MB")
        println("Average size of full GCs:\t" + avgSize + " MB")

        collectionTime += totalTime
        progressionTime = executionTime - collectionTime
    }
  }

  def getGCStatistics_ParallelGC(args: Array[String]) {

    println("Application:\t\t\t" + args(0))
    println("Worker node:\t\t\t" + args(1))

    var dirname: String = null
    var filename: String = null

    // han
    //adapt this to the path you store the driver and worker output folder generated by my memory profiler
    dirname = "/home/yuzhang/spark-1.5.1/logs/" + args(0) + "/" + args(1)
    (new File(dirname)).listFiles.filter(_.isDirectory).foreach {
      dir_container =>
        filename = dir_container.getAbsolutePath + "/stdout"
        println(filename)

        //  [PSYoungGen: 1572864K->29575K(1835008K)] 1572864K->29647K(6029312K), 0.0627010 secs] [Times: user=0.24 sys=0.05, real=0.06 secs] 
        executionTime = args(3).toDouble * 60
        println("Executirron time:\t" + executionTime + " sec")

        var fraction: Double = 0

        var totalTime: Double = 0
        var avgTime: Double = 0
        var numberOfGCs: Int = 0
        var totalSize: Double = 0
        var avgSize: Double = 0

        Source.fromFile(new File(filename)).getLines().filter(l => l.contains("[PSYoungGen:") && !l.contains("[ParOldGen:")).foreach {
          line =>
            numberOfGCs += 1
            line.split("\\s+").foreach {
              token =>
                //                println(token)
                if (token.contains("),")) {
                  var t1 = token.split("K|\\(|\\)|->|,").filter(t => t.length > 0).toArray
                  //                  println("=" + t1(0) + " - " + t1(1))
                  totalSize += t1(0).toDouble - t1(1).toDouble
                } else if (token.contains("real=")) {
                  val value = token.substring(token.indexOf('=') + 1).toDouble
                  totalTime += value
                }
            }
        }
        avgTime = totalTime / numberOfGCs
        println("-------- Young GC --------")
        println("Number of Young GCs:\t\t" + numberOfGCs)
        println("Total pause of Young GCs:\t" + totalTime + " sec")
        println("Average pause of Young GCs:\t" + avgTime + " sec")
        fraction = totalTime / executionTime
        println("Fraction of Young GCs:\t\t" + fraction)
        totalSize /= 1000
        avgSize = totalSize / numberOfGCs
        println("Total size of Young GCs:\t" + totalSize + " MB")
        println("Average size of Young GCs:\t" + avgSize + " MB")

        collectionTime += totalTime
        //        [PSYoungGen: 33006K->25175K(862720K)] [ParOldGen: 90231K->97479K(242688K)] 123238K->122654K(1105408K) [PSPermGen: 48764K->48721K(97792K)], 0.9404110 secs] [Times: user=4.88 sys=0.16, real=0.94 secs] 
        fraction = 0
        totalTime = 0
        avgTime = 0
        numberOfGCs = 0
        totalSize = 0
        avgSize = 0

        Source.fromFile(new File(filename)).getLines().filter(l => l.contains("[ParOldGen:")).foreach {
          l =>
            numberOfGCs += 1
            var tokens = l.split("\\s").filter(token => token.contains("->"))

            var t = tokens(2).split("M|\\(|\\)|->|\\]|K").filter(t => t.length > 0).toArray
            //            println("=" + t(0) + " - " + t(1))

            totalSize += t(0).toDouble - t(1).toDouble

            t = l.split("\\s").filter(token => token.contains("real=")).toArray
            totalTime += t.last.substring(t.last.indexOf("=") + 1).toDouble
        }
        avgTime = totalTime / numberOfGCs
        println("-------- Full GCs --------")
        println("Number of full GCs:\t\t" + numberOfGCs)
        println("Total pause of full GCs:\t" + totalTime + " sec")
        println("Average pause of full GCs:\t" + avgTime + " sec")
        fraction = totalTime / executionTime
        println("Fraction of full GCs:\t\t" + fraction)
        totalSize /= 1000
        avgSize = totalSize / numberOfGCs
        println("Total size of full GCs:\t\t" + totalSize + " MB")
        println("Average size of full GCs:\t" + avgSize + " MB")

        collectionTime += totalTime
        progressionTime = executionTime - collectionTime
    }
  }

  def getGeneratedHeapDataSize(args: Array[String]) {
    var usedHeap_old: Long = 0
    var generatedHeapDataSize: Long = 0
    var collectedHeapDataSize: Long = 0

    var filename: String = null
    filename = "/home/yuzhanghan1982/2015summer/results/" + args(2) + "/" + args(0) + "/" + args(1) + "/sparkOutput_worker_" + args(0) + "_" + args(1) + ".txt"
    Source.fromFile(new File(filename)).getLines().filter(l => l.contains("application") == false && l.contains("Old") == false).foreach {
      l =>
        val usedHeap = l.split("\\t")(6).toLong
        if (usedHeap > usedHeap_old) {
          generatedHeapDataSize += usedHeap - usedHeap_old
        } else if (usedHeap < usedHeap_old) {
          collectedHeapDataSize += usedHeap_old - usedHeap
        }
        if (usedHeap != usedHeap_old) {
          usedHeap_old = usedHeap
        }
    }

    println("-------- Data --------")
    println("Generated data in heap:\t\t" + generatedHeapDataSize / 1000000 + " MB")
    println("Progression time:\t\t" + progressionTime + " sec")
    println("Data generation rate:\t\t" + generatedHeapDataSize / 1000000 / progressionTime + " MB/sec")
    println("Collected data in heap:\t\t" + collectedHeapDataSize / 1000000 + " MB")
    println("Collection time:\t\t" + collectionTime + " sec")
    println("Data collection rate:\t\t" + collectedHeapDataSize / 1000000 / collectionTime + " MB/sec")
    println("Remaining data in heap:\t\t" + (generatedHeapDataSize - collectedHeapDataSize) / 1000000 + " MB")
  }
}